/*
 * Whisper Security API
 * # Whisper Security Threat Intelligence API  The Whisper Security API provides comprehensive threat intelligence, geolocation data, and security operations capabilities for enterprise security teams and developers.  ## Key Capabilities  - **Indicator Enrichment**: Get comprehensive intelligence on IP addresses and domains including   geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. - **Geolocation Services**: Fast IP-to-location lookups with ISP, ASN, and network information. - **Security Operations**: Asynchronous tools for bulk enrichment, infrastructure scanning,   AI-powered threat investigation, and monitoring.  ## API Design  - **RESTful**: Standard HTTP methods (GET, POST, PUT, DELETE) with JSON request/response bodies. - **Synchronous Endpoints**: Fast responses (<500ms) for indicator enrichment and geolocation. - **Asynchronous Jobs**: Long-running operations return a job ID for polling results. - **Consistent Error Handling**: Standardized error responses with status codes, error codes, and messages.  ## Authentication  All API endpoints require Bearer token authentication. Include your API key in the `Authorization` header: `Authorization: Bearer <your-api-key>`  ## Rate Limits  Rate limits are applied per-user and vary by endpoint category:  | Endpoint Category | Rate Limit | Description | |-------------------|------------|-------------| | Indicators (`/v1/indicators/_*`) | 100 req/sec | Single indicator enrichment | | Location (`/v1/location/_*`) | 100 req/sec | Geolocation lookups | | Jobs (`/v1/ops/jobs/_*`) | 100 req/sec | Job status and listing | | Bulk Operations (`/v1/ops/enrichment/bulk`) | 10 req/sec | Bulk indicator processing | | Screenshots (`/v1/ops/screenshots/_*`) | 10 req/sec | Screenshot capture and scheduling | | Scans (`/v1/ops/scans/_*`) | 10 req/sec | Infrastructure scanning | | Monitoring (`/v1/ops/monitoring/_*`) | 10 req/sec | Uptime monitoring | | Tracking (`/v1/ops/tracking/_*`) | 10 req/sec | Change tracking | | AI Investigate (`/v1/ops/ai/investigate`) | 5 req/min | Deep threat investigation | | AI Correlate (`/v1/ops/ai/correlate`) | 5 req/min | Global correlation | | AI Attribute (`/v1/ops/ai/attribute`) | 5 req/min | Threat actor attribution | | AI Pivot (`/v1/ops/ai/pivot`) | 5 req/min | Infrastructure pivoting |  When rate limits are exceeded, the API returns HTTP `429 Too Many Requests` with a `Retry-After` header indicating when you can retry. The response body includes: ```json {   \"error\": \"Too Many Requests\",   \"message\": \"Rate limit exceeded for <category>. Please retry after N seconds.\",   \"retryAfter\": N } ```  ## Response Conventions  - All timestamps are in ISO 8601 format (UTC). - Pagination uses `limit` and `offset` parameters. - Field names use camelCase throughout the API.  ## Official SDKs  - **Python**: [github.com/whisper-sec/sdk-python](https://github.com/whisper-sec/sdk-python) - **TypeScript/JavaScript**: [github.com/whisper-sec/sdk-typescript](https://github.com/whisper-sec/sdk-typescript) - **Java**: [github.com/whisper-sec/sdk-java](https://github.com/whisper-sec/sdk-java) - **C#/.NET**: [github.com/whisper-sec/sdk-csharp](https://github.com/whisper-sec/sdk-csharp)  ## Resources  - **Website**: [whisper.security](https://whisper.security) - **Dashboard**: [dash.whisper.security](https://dash.whisper.security) - Manage API keys and view usage - **Documentation**: [docs.whisper.security](https://docs.whisper.security) - Guides and tutorials 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@whisper.security
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.github.whispersec.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Locale;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.github.whispersec.model.CityInfo;
import io.github.whispersec.model.CoordinatesInfo;
import io.github.whispersec.model.CountryInfo;
import io.github.whispersec.model.IspInfo;
import io.github.whispersec.model.LocationInfo;
import io.github.whispersec.model.TraitsInfo;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * Geolocation and network information for an IP address
 */
@JsonPropertyOrder({
  IpGeolocationResponse.JSON_PROPERTY_IP,
  IpGeolocationResponse.JSON_PROPERTY_COUNTRY,
  IpGeolocationResponse.JSON_PROPERTY_CITY,
  IpGeolocationResponse.JSON_PROPERTY_LOCATION,
  IpGeolocationResponse.JSON_PROPERTY_ISP,
  IpGeolocationResponse.JSON_PROPERTY_TRAITS,
  IpGeolocationResponse.JSON_PROPERTY_COORDINATES
})
@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-12-12T20:10:38.516211554Z[Etc/UTC]", comments = "Generator version: 7.17.0")
public class IpGeolocationResponse {
  public static final String JSON_PROPERTY_IP = "ip";
  @jakarta.annotation.Nullable
  private String ip;

  public static final String JSON_PROPERTY_COUNTRY = "country";
  @jakarta.annotation.Nullable
  private CountryInfo country;

  public static final String JSON_PROPERTY_CITY = "city";
  @jakarta.annotation.Nullable
  private CityInfo city;

  public static final String JSON_PROPERTY_LOCATION = "location";
  @jakarta.annotation.Nullable
  private LocationInfo location;

  public static final String JSON_PROPERTY_ISP = "isp";
  @jakarta.annotation.Nullable
  private IspInfo isp;

  public static final String JSON_PROPERTY_TRAITS = "traits";
  @jakarta.annotation.Nullable
  private TraitsInfo traits;

  public static final String JSON_PROPERTY_COORDINATES = "coordinates";
  @jakarta.annotation.Nullable
  private CoordinatesInfo coordinates;

  public IpGeolocationResponse() {
  }

  public IpGeolocationResponse ip(@jakarta.annotation.Nullable String ip) {
    
    this.ip = ip;
    return this;
  }

  /**
   * The queried IP address
   * @return ip
   */
  @jakarta.annotation.Nullable
  @JsonProperty(value = JSON_PROPERTY_IP, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getIp() {
    return ip;
  }


  @JsonProperty(value = JSON_PROPERTY_IP, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIp(@jakarta.annotation.Nullable String ip) {
    this.ip = ip;
  }

  public IpGeolocationResponse country(@jakarta.annotation.Nullable CountryInfo country) {
    
    this.country = country;
    return this;
  }

  /**
   * Country information
   * @return country
   */
  @jakarta.annotation.Nullable
  @JsonProperty(value = JSON_PROPERTY_COUNTRY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public CountryInfo getCountry() {
    return country;
  }


  @JsonProperty(value = JSON_PROPERTY_COUNTRY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCountry(@jakarta.annotation.Nullable CountryInfo country) {
    this.country = country;
  }

  public IpGeolocationResponse city(@jakarta.annotation.Nullable CityInfo city) {
    
    this.city = city;
    return this;
  }

  /**
   * City information
   * @return city
   */
  @jakarta.annotation.Nullable
  @JsonProperty(value = JSON_PROPERTY_CITY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public CityInfo getCity() {
    return city;
  }


  @JsonProperty(value = JSON_PROPERTY_CITY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCity(@jakarta.annotation.Nullable CityInfo city) {
    this.city = city;
  }

  public IpGeolocationResponse location(@jakarta.annotation.Nullable LocationInfo location) {
    
    this.location = location;
    return this;
  }

  /**
   * Geographic location details
   * @return location
   */
  @jakarta.annotation.Nullable
  @JsonProperty(value = JSON_PROPERTY_LOCATION, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public LocationInfo getLocation() {
    return location;
  }


  @JsonProperty(value = JSON_PROPERTY_LOCATION, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLocation(@jakarta.annotation.Nullable LocationInfo location) {
    this.location = location;
  }

  public IpGeolocationResponse isp(@jakarta.annotation.Nullable IspInfo isp) {
    
    this.isp = isp;
    return this;
  }

  /**
   * Internet Service Provider and network information
   * @return isp
   */
  @jakarta.annotation.Nullable
  @JsonProperty(value = JSON_PROPERTY_ISP, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public IspInfo getIsp() {
    return isp;
  }


  @JsonProperty(value = JSON_PROPERTY_ISP, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIsp(@jakarta.annotation.Nullable IspInfo isp) {
    this.isp = isp;
  }

  public IpGeolocationResponse traits(@jakarta.annotation.Nullable TraitsInfo traits) {
    
    this.traits = traits;
    return this;
  }

  /**
   * IP classification and traits
   * @return traits
   */
  @jakarta.annotation.Nullable
  @JsonProperty(value = JSON_PROPERTY_TRAITS, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public TraitsInfo getTraits() {
    return traits;
  }


  @JsonProperty(value = JSON_PROPERTY_TRAITS, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTraits(@jakarta.annotation.Nullable TraitsInfo traits) {
    this.traits = traits;
  }

  public IpGeolocationResponse coordinates(@jakarta.annotation.Nullable CoordinatesInfo coordinates) {
    
    this.coordinates = coordinates;
    return this;
  }

  /**
   * Geographic coordinates (convenience field)
   * @return coordinates
   */
  @jakarta.annotation.Nullable
  @JsonProperty(value = JSON_PROPERTY_COORDINATES, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public CoordinatesInfo getCoordinates() {
    return coordinates;
  }


  @JsonProperty(value = JSON_PROPERTY_COORDINATES, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCoordinates(@jakarta.annotation.Nullable CoordinatesInfo coordinates) {
    this.coordinates = coordinates;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IpGeolocationResponse ipGeolocationResponse = (IpGeolocationResponse) o;
    return Objects.equals(this.ip, ipGeolocationResponse.ip) &&
        Objects.equals(this.country, ipGeolocationResponse.country) &&
        Objects.equals(this.city, ipGeolocationResponse.city) &&
        Objects.equals(this.location, ipGeolocationResponse.location) &&
        Objects.equals(this.isp, ipGeolocationResponse.isp) &&
        Objects.equals(this.traits, ipGeolocationResponse.traits) &&
        Objects.equals(this.coordinates, ipGeolocationResponse.coordinates);
  }

  @Override
  public int hashCode() {
    return Objects.hash(ip, country, city, location, isp, traits, coordinates);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IpGeolocationResponse {\n");
    sb.append("    ip: ").append(toIndentedString(ip)).append("\n");
    sb.append("    country: ").append(toIndentedString(country)).append("\n");
    sb.append("    city: ").append(toIndentedString(city)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    isp: ").append(toIndentedString(isp)).append("\n");
    sb.append("    traits: ").append(toIndentedString(traits)).append("\n");
    sb.append("    coordinates: ").append(toIndentedString(coordinates)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

