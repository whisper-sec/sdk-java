/*
 * Whisper Security API
 * # Whisper Security Threat Intelligence API  The Whisper Security API provides comprehensive threat intelligence, geolocation data, and security operations capabilities for enterprise security teams and developers.  ## Key Capabilities  - **Indicator Enrichment**: Get comprehensive intelligence on IP addresses and domains including   geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. - **Geolocation Services**: Fast IP-to-location lookups with ISP, ASN, and network information. - **Security Operations**: Asynchronous tools for bulk enrichment, infrastructure scanning,   AI-powered threat investigation, and monitoring.  ## API Design  - **RESTful**: Standard HTTP methods (GET, POST, PUT, DELETE) with JSON request/response bodies. - **Synchronous Endpoints**: Fast responses (<500ms) for indicator enrichment and geolocation. - **Asynchronous Jobs**: Long-running operations return a job ID for polling results. - **Consistent Error Handling**: Standardized error responses with status codes, error codes, and messages.  ## Authentication  All API endpoints require Bearer token authentication. Include your API key in the `Authorization` header: `Authorization: Bearer <your-api-key>`  ## Rate Limits  Rate limits are applied per-user and vary by endpoint category:  | Endpoint Category | Rate Limit | Description | |-------------------|------------|-------------| | Indicators (`/v1/indicators/_*`) | 100 req/sec | Single indicator enrichment | | Location (`/v1/location/_*`) | 100 req/sec | Geolocation lookups | | Jobs (`/v1/ops/jobs/_*`) | 100 req/sec | Job status and listing | | Bulk Operations (`/v1/ops/enrichment/bulk`) | 10 req/sec | Bulk indicator processing | | Screenshots (`/v1/ops/screenshots/_*`) | 10 req/sec | Screenshot capture and scheduling | | Scans (`/v1/ops/scans/_*`) | 10 req/sec | Infrastructure scanning | | Monitoring (`/v1/ops/monitoring/_*`) | 10 req/sec | Uptime monitoring | | Tracking (`/v1/ops/tracking/_*`) | 10 req/sec | Change tracking | | AI Investigate (`/v1/ops/ai/investigate`) | 5 req/min | Deep threat investigation | | AI Correlate (`/v1/ops/ai/correlate`) | 5 req/min | Global correlation | | AI Attribute (`/v1/ops/ai/attribute`) | 5 req/min | Threat actor attribution | | AI Pivot (`/v1/ops/ai/pivot`) | 5 req/min | Infrastructure pivoting |  When rate limits are exceeded, the API returns HTTP `429 Too Many Requests` with a `Retry-After` header indicating when you can retry. The response body includes: ```json {   \"error\": \"Too Many Requests\",   \"message\": \"Rate limit exceeded for <category>. Please retry after N seconds.\",   \"retryAfter\": N } ```  ## Response Conventions  - All timestamps are in ISO 8601 format (UTC). - Pagination uses `limit` and `offset` parameters. - Field names use camelCase throughout the API.  ## Official SDKs  - **Python**: [github.com/whisper-sec/sdk-python](https://github.com/whisper-sec/sdk-python) - **TypeScript/JavaScript**: [github.com/whisper-sec/sdk-typescript](https://github.com/whisper-sec/sdk-typescript) - **Java**: [github.com/whisper-sec/sdk-java](https://github.com/whisper-sec/sdk-java) - **C#/.NET**: [github.com/whisper-sec/sdk-csharp](https://github.com/whisper-sec/sdk-csharp)  ## Resources  - **Website**: [whisper.security](https://whisper.security) - **Dashboard**: [dash.whisper.security](https://dash.whisper.security) - Manage API keys and view usage - **Documentation**: [docs.whisper.security](https://docs.whisper.security) - Guides and tutorials 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@whisper.security
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.github.whispersec.api;

import io.github.whispersec.model.ErrorResponse;
import io.github.whispersec.model.GenericSuccessResponse;
import io.github.whispersec.model.JobResponse;
import io.github.whispersec.model.MonitorCheckRequest;
import io.github.whispersec.model.MonitorCheckResponse;
import io.github.whispersec.model.MonitorDashboardResponse;
import io.github.whispersec.model.MonitorListResponse;
import io.github.whispersec.model.MonitorResultListResponse;
import io.github.whispersec.model.MonitoringAlertRequest;
import io.github.whispersec.model.MonitoringStatusResponse;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * API tests for MonitoringApi
 */
@Disabled
public class MonitoringApiTest {

    private final MonitoringApi api = new MonitoringApi();

    
    /**
     * Create Monitoring Check
     *
     * &lt;p&gt;Create a new monitoring check to track uptime and performance of a URL or endpoint.&lt;/p&gt; &lt;h4&gt;Check Types:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;api:&lt;/b&gt; HTTP/HTTPS endpoint monitoring - checks status code, response time, content&lt;/li&gt;     &lt;li&gt;&lt;b&gt;ssl:&lt;/b&gt; SSL certificate monitoring - validates certificate and tracks expiry&lt;/li&gt;     &lt;li&gt;&lt;b&gt;dns:&lt;/b&gt; DNS record monitoring - validates DNS resolution and record values&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Frequency Options:&lt;/h4&gt; &lt;p&gt;Check frequency in minutes: 1, 5, 10, 15, 30, 60, 1440 (daily)&lt;/p&gt; &lt;h4&gt;Locations:&lt;/h4&gt; &lt;p&gt;Checks can run from multiple global locations: us-east-1, us-west-1, eu-west-1, ap-southeast-1&lt;/p&gt; 
     */
    @Test
    public void createMonitorCheckTest()  {
        // uncomment below to test the function
        //MonitorCheckRequest monitorCheckRequest = null;
        //MonitorCheckResponse response = api.createMonitorCheck(monitorCheckRequest).block();

        // TODO: test validations
    }
    
    /**
     * Configure Monitoring Alert
     *
     * &lt;p&gt;Configure alert notifications for a monitored target. Set up notifications for downtime, SSL expiry, DNS changes, and more.&lt;/p&gt; &lt;h4&gt;Alert Types:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;downtime:&lt;/b&gt; Alert when target becomes unreachable&lt;/li&gt;     &lt;li&gt;&lt;b&gt;dns_change:&lt;/b&gt; Alert when DNS records change&lt;/li&gt;     &lt;li&gt;&lt;b&gt;whois_change:&lt;/b&gt; Alert when WHOIS data changes&lt;/li&gt;     &lt;li&gt;&lt;b&gt;ssl_expiring:&lt;/b&gt; Alert when SSL certificate is expiring (within threshold days)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;content_change:&lt;/b&gt; Alert when page content changes significantly&lt;/li&gt;     &lt;li&gt;&lt;b&gt;technology_change:&lt;/b&gt; Alert when detected technologies change&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Notification Channels:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;email:&lt;/b&gt; Send alerts via email&lt;/li&gt;     &lt;li&gt;&lt;b&gt;slack:&lt;/b&gt; Post to Slack webhook&lt;/li&gt;     &lt;li&gt;&lt;b&gt;webhook:&lt;/b&gt; POST to custom webhook URL&lt;/li&gt;     &lt;li&gt;&lt;b&gt;pagerduty:&lt;/b&gt; Create PagerDuty incident&lt;/li&gt; &lt;/ul&gt; 
     */
    @Test
    public void createMonitoringAlertTest()  {
        // uncomment below to test the function
        //String target = null;
        //MonitoringAlertRequest monitoringAlertRequest = null;
        //JobResponse response = api.createMonitoringAlert(target, monitoringAlertRequest).block();

        // TODO: test validations
    }
    
    /**
     * Delete Monitoring Check
     *
     * Delete a monitoring check and stop all monitoring for the target.
     */
    @Test
    public void deleteMonitorCheckTest()  {
        // uncomment below to test the function
        //String checkId = null;
        //Object response = api.deleteMonitorCheck(checkId).block();

        // TODO: test validations
    }
    
    /**
     * Get Monitoring Check
     *
     * Get details of a specific monitoring check including uptime metrics.
     */
    @Test
    public void getMonitorCheckTest()  {
        // uncomment below to test the function
        //String checkId = null;
        //MonitorCheckResponse response = api.getMonitorCheck(checkId).block();

        // TODO: test validations
    }
    
    /**
     * Get Monitoring Dashboard
     *
     * &lt;p&gt;Get aggregated dashboard statistics for all monitoring checks.&lt;/p&gt; &lt;h4&gt;Includes:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Total, passing, failing, and degraded check counts&lt;/li&gt;     &lt;li&gt;Average uptime percentages (24h, 7d, 30d)&lt;/li&gt;     &lt;li&gt;Average response time&lt;/li&gt;     &lt;li&gt;Checks grouped by type and status&lt;/li&gt; &lt;/ul&gt; 
     */
    @Test
    public void getMonitorDashboardTest()  {
        // uncomment below to test the function
        //MonitorDashboardResponse response = api.getMonitorDashboard().block();

        // TODO: test validations
    }
    
    /**
     * Get Check Results
     *
     * &lt;p&gt;Get the execution history for a monitoring check.&lt;/p&gt; &lt;h4&gt;Response includes for each result:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Timestamp of execution&lt;/li&gt;     &lt;li&gt;Success/failure status&lt;/li&gt;     &lt;li&gt;Response time&lt;/li&gt;     &lt;li&gt;HTTP status code (for API checks)&lt;/li&gt;     &lt;li&gt;Error message (if failed)&lt;/li&gt; &lt;/ul&gt; 
     */
    @Test
    public void getMonitorResultsTest()  {
        // uncomment below to test the function
        //String checkId = null;
        //Integer limit = null;
        //MonitorResultListResponse response = api.getMonitorResults(checkId, limit).block();

        // TODO: test validations
    }
    
    /**
     * Get Monitoring Status
     *
     * &lt;p&gt;Get the current monitoring status and metrics for a domain or IP address.&lt;/p&gt; &lt;h4&gt;Metrics Returned:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Uptime percentage (last 30 days)&lt;/li&gt;     &lt;li&gt;Average response time&lt;/li&gt;     &lt;li&gt;SSL certificate expiration countdown&lt;/li&gt;     &lt;li&gt;DNS change events&lt;/li&gt;     &lt;li&gt;WHOIS change events&lt;/li&gt; &lt;/ul&gt; 
     */
    @Test
    public void getMonitoringStatusTest()  {
        // uncomment below to test the function
        //String target = null;
        //MonitoringStatusResponse response = api.getMonitoringStatus(target).block();

        // TODO: test validations
    }
    
    /**
     * List Monitoring Checks
     *
     * &lt;p&gt;Get a list of all monitoring checks created by the authenticated user.&lt;/p&gt; &lt;h4&gt;Filtering:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;type:&lt;/b&gt; Filter by check type (api, ssl, dns)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;status:&lt;/b&gt; Filter by status (passing, failing, degraded, pending)&lt;/li&gt; &lt;/ul&gt; 
     */
    @Test
    public void listMonitorChecksTest()  {
        // uncomment below to test the function
        //String type = null;
        //String status = null;
        //MonitorListResponse response = api.listMonitorChecks(type, status).block();

        // TODO: test validations
    }
    
    /**
     * Trigger Manual Check
     *
     * Trigger an immediate execution of a monitoring check.
     */
    @Test
    public void triggerMonitorCheckTest()  {
        // uncomment below to test the function
        //String checkId = null;
        //GenericSuccessResponse response = api.triggerMonitorCheck(checkId).block();

        // TODO: test validations
    }
    
    /**
     * Update Monitoring Check
     *
     * Update an existing monitoring check configuration.
     */
    @Test
    public void updateMonitorCheckTest()  {
        // uncomment below to test the function
        //String checkId = null;
        //MonitorCheckRequest monitorCheckRequest = null;
        //MonitorCheckResponse response = api.updateMonitorCheck(checkId, monitorCheckRequest).block();

        // TODO: test validations
    }
    
}
