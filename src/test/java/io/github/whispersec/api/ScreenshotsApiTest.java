/*
 * Whisper Security API
 * # Whisper Security Threat Intelligence API  The Whisper Security API provides comprehensive threat intelligence, geolocation data, and security operations capabilities for enterprise security teams and developers.  ## Key Capabilities  - **Indicator Enrichment**: Get comprehensive intelligence on IP addresses and domains including   geolocation, WHOIS, DNS, reputation scoring, and relationship mapping. - **Geolocation Services**: Fast IP-to-location lookups with ISP, ASN, and network information. - **Security Operations**: Asynchronous tools for bulk enrichment, infrastructure scanning,   AI-powered threat investigation, and monitoring.  ## API Design  - **RESTful**: Standard HTTP methods (GET, POST, PUT, DELETE) with JSON request/response bodies. - **Synchronous Endpoints**: Fast responses (<500ms) for indicator enrichment and geolocation. - **Asynchronous Jobs**: Long-running operations return a job ID for polling results. - **Consistent Error Handling**: Standardized error responses with status codes, error codes, and messages.  ## Authentication  All API endpoints require Bearer token authentication. Include your API key in the `Authorization` header: `Authorization: Bearer <your-api-key>`  ## Rate Limits  Rate limits are applied per-user and vary by endpoint category:  | Endpoint Category | Rate Limit | Description | |-------------------|------------|-------------| | Indicators (`/v1/indicators/_*`) | 100 req/sec | Single indicator enrichment | | Location (`/v1/location/_*`) | 100 req/sec | Geolocation lookups | | Jobs (`/v1/ops/jobs/_*`) | 100 req/sec | Job status and listing | | Bulk Operations (`/v1/ops/enrichment/bulk`) | 10 req/sec | Bulk indicator processing | | Screenshots (`/v1/ops/screenshots/_*`) | 10 req/sec | Screenshot capture and scheduling | | Scans (`/v1/ops/scans/_*`) | 10 req/sec | Infrastructure scanning | | Monitoring (`/v1/ops/monitoring/_*`) | 10 req/sec | Uptime monitoring | | Tracking (`/v1/ops/tracking/_*`) | 10 req/sec | Change tracking | | AI Investigate (`/v1/ops/ai/investigate`) | 5 req/min | Deep threat investigation | | AI Correlate (`/v1/ops/ai/correlate`) | 5 req/min | Global correlation | | AI Attribute (`/v1/ops/ai/attribute`) | 5 req/min | Threat actor attribution | | AI Pivot (`/v1/ops/ai/pivot`) | 5 req/min | Infrastructure pivoting |  When rate limits are exceeded, the API returns HTTP `429 Too Many Requests` with a `Retry-After` header indicating when you can retry. The response body includes: ```json {   \"error\": \"Too Many Requests\",   \"message\": \"Rate limit exceeded for <category>. Please retry after N seconds.\",   \"retryAfter\": N } ```  ## Response Conventions  - All timestamps are in ISO 8601 format (UTC). - Pagination uses `limit` and `offset` parameters. - Field names use camelCase throughout the API.  ## Official SDKs  - **Python**: [github.com/whisper-sec/sdk-python](https://github.com/whisper-sec/sdk-python) - **TypeScript/JavaScript**: [github.com/whisper-sec/sdk-typescript](https://github.com/whisper-sec/sdk-typescript) - **Java**: [github.com/whisper-sec/sdk-java](https://github.com/whisper-sec/sdk-java) - **C#/.NET**: [github.com/whisper-sec/sdk-csharp](https://github.com/whisper-sec/sdk-csharp)  ## Resources  - **Website**: [whisper.security](https://whisper.security) - **Dashboard**: [dash.whisper.security](https://dash.whisper.security) - Manage API keys and view usage - **Documentation**: [docs.whisper.security](https://docs.whisper.security) - Guides and tutorials 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@whisper.security
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.github.whispersec.api;

import io.github.whispersec.model.ErrorResponse;
import io.github.whispersec.model.JobResponse;
import io.github.whispersec.model.ScreenshotHistoryResponse;
import io.github.whispersec.model.ScreenshotRequest;
import io.github.whispersec.model.ScreenshotSchedule;
import io.github.whispersec.model.ScreenshotScheduleListResponse;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * API tests for ScreenshotsApi
 */
@Disabled
public class ScreenshotsApiTest {

    private final ScreenshotsApi api = new ScreenshotsApi();

    
    /**
     * Clear Screenshot History
     *
     * &lt;p&gt;Delete all captured screenshots for a schedule while keeping the schedule active.&lt;/p&gt; &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; This action cannot be undone. All screenshots will be permanently deleted.&lt;/p&gt; 
     */
    @Test
    public void clearScreenshotHistoryTest()  {
        // uncomment below to test the function
        //String scheduleId = null;
        //Object response = api.clearScreenshotHistory(scheduleId).block();

        // TODO: test validations
    }
    
    /**
     * Capture a Website Screenshot (Asynchronous)
     *
     * &lt;p&gt;Initiates an asynchronous job to capture a screenshot of a website. Supports various viewport sizes, full-page captures, and JavaScript rendering.&lt;/p&gt; &lt;p&gt;&lt;b&gt;Performance Note:&lt;/b&gt; A typical screenshot capture takes 10-30 seconds. Poll the &#x60;/v1/ops/jobs/{jobId}&#x60; endpoint to retrieve the URL of the final image.&lt;/p&gt; &lt;p&gt;&lt;b&gt;Output:&lt;/b&gt; The job result will contain a URL to download the screenshot image in the specified format (PNG, JPEG, or WebP).&lt;/p&gt; 
     */
    @Test
    public void createScreenshotTest()  {
        // uncomment below to test the function
        //ScreenshotRequest screenshotRequest = null;
        //JobResponse response = api.createScreenshot(screenshotRequest).block();

        // TODO: test validations
    }
    
    /**
     * Delete Screenshot Schedule
     *
     * &lt;p&gt;Delete a scheduled screenshot configuration and optionally all its captured screenshots.&lt;/p&gt; &lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt; This action cannot be undone. All associated screenshots will be permanently deleted.&lt;/p&gt; 
     */
    @Test
    public void deleteScreenshotScheduleTest()  {
        // uncomment below to test the function
        //String scheduleId = null;
        //Object response = api.deleteScreenshotSchedule(scheduleId).block();

        // TODO: test validations
    }
    
    /**
     * Get Screenshot History
     *
     * &lt;p&gt;Retrieve all previously captured screenshots for a specific URL, ordered by capture time (newest first). Includes download URLs and metadata for each capture.&lt;/p&gt; &lt;h4&gt;Response Includes:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Download URL:&lt;/b&gt; Direct link to screenshot image&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Capture Time:&lt;/b&gt; Timestamp when screenshot was taken&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Dimensions:&lt;/b&gt; Image width and height&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Format:&lt;/b&gt; Image format (PNG, JPEG, WebP)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;File Size:&lt;/b&gt; Size in bytes&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Review website evolution over time&lt;/li&gt;     &lt;li&gt;Compare screenshots for change detection&lt;/li&gt;     &lt;li&gt;Download historical screenshots for reporting&lt;/li&gt; &lt;/ul&gt; 
     */
    @Test
    public void getScreenshotHistoryTest()  {
        // uncomment below to test the function
        //String target = null;
        //Integer limit = null;
        //ScreenshotHistoryResponse response = api.getScreenshotHistory(target, limit).block();

        // TODO: test validations
    }
    
    /**
     * Get Screenshot Schedule Details
     *
     * &lt;p&gt;Retrieve details for a specific screenshot schedule including configuration and capture history.&lt;/p&gt; 
     */
    @Test
    public void getScreenshotScheduleTest()  {
        // uncomment below to test the function
        //String scheduleId = null;
        //ScreenshotSchedule response = api.getScreenshotSchedule(scheduleId).block();

        // TODO: test validations
    }
    
    /**
     * List Screenshot Schedules
     *
     * &lt;p&gt;Retrieve all scheduled screenshot configurations for your API key. Each API key can have a maximum of 3 active schedules.&lt;/p&gt; &lt;h4&gt;Response Includes:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Schedule ID:&lt;/b&gt; Unique identifier for the schedule&lt;/li&gt;     &lt;li&gt;&lt;b&gt;URL:&lt;/b&gt; Target website being captured&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Frequency:&lt;/b&gt; How often screenshots are taken&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Next Capture:&lt;/b&gt; When the next screenshot will be taken&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Capture Count:&lt;/b&gt; Total screenshots taken by this schedule&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Status:&lt;/b&gt; Whether the schedule is enabled or paused&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Limits:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Max Schedules:&lt;/b&gt; 3 per API key&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Max Screenshots:&lt;/b&gt; 50 retained per schedule (oldest deleted automatically)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Schedule Expiration:&lt;/b&gt; Schedules auto-expire after 90 days of inactivity&lt;/li&gt; &lt;/ul&gt; 
     */
    @Test
    public void listScreenshotSchedulesTest()  {
        // uncomment below to test the function
        //ScreenshotScheduleListResponse response = api.listScreenshotSchedules().block();

        // TODO: test validations
    }
    
    /**
     * Schedule Recurring Screenshots (Asynchronous)
     *
     * &lt;p&gt;Create a recurring job to capture website screenshots at regular intervals. Essential for monitoring website changes, detecting defacements, and tracking competitor updates.&lt;/p&gt; &lt;h4&gt;Schedule Options:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Cron Expression:&lt;/b&gt; Full cron syntax support (e.g., &#x60;0 0 * * * *&#x60; &#x3D; hourly)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Frequency Presets:&lt;/b&gt; hourly, every_6_hours, every_12_hours, twice_daily, daily, weekly, monthly&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Timezone:&lt;/b&gt; Specify timezone for accurate scheduling (default: UTC)&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;First Screenshot:&lt;/h4&gt; &lt;p&gt;The &lt;b&gt;first screenshot is captured immediately&lt;/b&gt; when a schedule is created. Subsequent screenshots follow the configured schedule. This ensures you have baseline data right away.&lt;/p&gt; &lt;h4&gt;Limits:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Max Schedules:&lt;/b&gt; 3 per API key&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Max Screenshots:&lt;/b&gt; 50 retained per schedule (oldest deleted automatically)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Schedule Expiration:&lt;/b&gt; Schedules auto-expire after 90 days of inactivity&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Screenshot Retention:&lt;/b&gt; Individual screenshots expire after 14 days&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Setup Time:&lt;/b&gt; ~2 seconds to create schedule&lt;/li&gt;     &lt;li&gt;&lt;b&gt;First Screenshot:&lt;/b&gt; Triggered immediately on schedule creation&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Screenshot Time:&lt;/b&gt; 10-30 seconds per capture&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Automated defacement detection&lt;/li&gt;     &lt;li&gt;Compliance monitoring and archival&lt;/li&gt;     &lt;li&gt;Competitor website tracking&lt;/li&gt;     &lt;li&gt;Visual regression testing&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Management:&lt;/h4&gt; &lt;p&gt;Use &lt;code&gt;GET /v1/ops/screenshots/schedules&lt;/code&gt; to list schedules, &lt;code&gt;DELETE /v1/ops/screenshots/schedules/{id}&lt;/code&gt; to delete.&lt;/p&gt; 
     */
    @Test
    public void scheduleScreenshotTest()  {
        // uncomment below to test the function
        //ScreenshotRequest screenshotRequest = null;
        //JobResponse response = api.scheduleScreenshot(screenshotRequest).block();

        // TODO: test validations
    }
    
}
