/*
 * Whisper API v1
 * <h2>The Foundational Intelligence Layer for the Internet</h2> <p>The Whisper API provides comprehensive, real-time intelligence on any internet asset. By connecting billions of data points across live internet routing, historical registration records, and deep resolution data, our API moves beyond simple enrichment to deliver predictive, context-rich insights.</p> <p>This document is the single source of truth for our v1 API. It is designed for security experts, developers, and automated systems to understand and leverage the full power of our platform.</p>  <h3>üöÄ Quick Start</h3> <p><b>1. Get your API key:</b> <a href=\"https://dash.whisper.security\">Sign up at dash.whisper.security</a></p> <p><b>2. Make your first request:</b></p> <pre><code>curl -H \"Authorization: Bearer YOUR_API_KEY\" https://api.whisper.security/v1/indicators/ip/8.8.8.8</code></pre> <p><b>3. Explore the API:</b> Use the \"Try it out\" button in each endpoint below to test interactively.</p>  <h3>üéØ Key Features</h3> <ul>     <li><b>Unified & Simple:</b> Small set of powerful, resource-oriented endpoints</li>     <li><b>Performant by Design:</b> Asynchronous-first with strategic caching (&lt;500ms typical response)</li>     <li><b>Workflow-Oriented:</b> Built for real-world security operations, not just data dumps</li>     <li><b>Comprehensive:</b> IP, Domain, DNS, WHOIS, Routing, Geolocation, Screenshots, Monitoring</li> </ul>  <h3>‚ö° Performance Targets</h3> <table>     <tr><th>Endpoint Type</th><th>Response Time</th><th>Use Case</th></tr>     <tr><td>Geolocation</td><td>&lt;150ms</td><td>Real-time fraud detection</td></tr>     <tr><td>Single Indicator</td><td>&lt;500ms</td><td>Incident response enrichment</td></tr>     <tr><td>With Routing Data</td><td>&lt;2s (cached: 200ms)</td><td>Deep network analysis</td></tr>     <tr><td>Bulk Operations</td><td>5-30s</td><td>Batch log enrichment</td></tr>     <tr><td>Search/Discovery</td><td>10-60s</td><td>Threat hunting</td></tr> </table>  <h3>üîê Authentication</h3> <p>All endpoints require Bearer token authentication. Click the <b>\"Authorize\"</b> button above and enter your API key.</p> <pre><code>Authorization: Bearer wsk_live_1234567890abcdef</code></pre>  <h3>üìä Rate Limits</h3> <table>     <tr><th>Category</th><th>Limit</th></tr>     <tr><td>Standard Enrichment</td><td>100 req/min</td></tr>     <tr><td>Bulk Operations</td><td>10 req/min</td></tr>     <tr><td>Search/Discovery</td><td>5 req/min</td></tr>     <tr><td>Screenshots</td><td>10 req/min</td></tr> </table> <p><i>Rate limits return HTTP 429. Retry after the time specified in the <code>Retry-After</code> header.</i></p>  <h3>üìö Resources</h3> <ul>     <li><a href=\"https://docs.whisper.security\">Full Documentation</a></li>     <li><a href=\"https://docs.whisper.security/quickstart\">Quick Start Guide</a></li>     <li><a href=\"https://docs.whisper.security/examples\">Code Examples</a></li>     <li><a href=\"https://whisper.security/support\">API Support</a></li> </ul> 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api-support@whisper.security
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package io.github.whispersec.api;

import io.github.whispersec.model.ErrorResponse;
import io.github.whispersec.model.InfrastructureMapRequest;
import io.github.whispersec.model.Job;
import io.github.whispersec.model.JobResponse;
import io.github.whispersec.model.MonitoringAlertRequest;
import io.github.whispersec.model.ScanRequest;
import io.github.whispersec.model.ScreenshotRequest;
import io.github.whispersec.model.SimilarDomainsOpsRequest;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * API tests for OperationsApi
 */
@Disabled
public class OperationsApiTest {

    private final OperationsApi api = new OperationsApi();

    
    /**
     * Map Infrastructure Relationships (Asynchronous)
     *
     * &lt;p&gt;Creates a comprehensive map of infrastructure relationships starting from a domain or IP. Discovers connected assets through shared hosting, DNS, certificates, and network relationships.&lt;/p&gt; &lt;h4&gt;Mapping Depth Levels:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Depth 1:&lt;/b&gt; Direct relationships only (~30 seconds, 10-50 assets)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Depth 2:&lt;/b&gt; 2 hops out (~2-5 minutes, 50-500 assets)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Depth 3:&lt;/b&gt; 3 hops out (~10-30 minutes, 500-5000 assets)&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Relationship Types Discovered:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Domains on same IP&lt;/li&gt;     &lt;li&gt;Domains sharing nameservers&lt;/li&gt;     &lt;li&gt;Domains with same SSL certificate&lt;/li&gt;     &lt;li&gt;IPs in same ASN&lt;/li&gt;     &lt;li&gt;Domains with same registrant&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Output Format:&lt;/h4&gt; &lt;p&gt;Results returned as graph data compatible with visualization libraries (nodes and edges).&lt;/p&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Threat actor infrastructure mapping&lt;/li&gt;     &lt;li&gt;Discovering related phishing domains&lt;/li&gt;     &lt;li&gt;Finding shadow IT and forgotten assets&lt;/li&gt; &lt;/ul&gt; 
     */
    @Test
    public void createInfrastructureMapTest()  {
        // uncomment below to test the function
        //InfrastructureMapRequest infrastructureMapRequest = null;
        //JobResponse response = api.createInfrastructureMap(infrastructureMapRequest).block();

        // TODO: test validations
    }
    
    /**
     * Infrastructure Security Scan (Asynchronous)
     *
     * &lt;p&gt;Initiates a comprehensive security scan of a domain&#39;s infrastructure. Performs reconnaissance, port scanning, service detection, and vulnerability assessment.&lt;/p&gt; &lt;h4&gt;Scan Types:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;comprehensive:&lt;/b&gt; Full scan including all modules (recommended for complete assessment)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;subdomains:&lt;/b&gt; Subdomain enumeration only&lt;/li&gt;     &lt;li&gt;&lt;b&gt;ports:&lt;/b&gt; Port scanning and service detection&lt;/li&gt;     &lt;li&gt;&lt;b&gt;technologies:&lt;/b&gt; Technology stack detection&lt;/li&gt;     &lt;li&gt;&lt;b&gt;vulnerabilities:&lt;/b&gt; Known vulnerability checks&lt;/li&gt;     &lt;li&gt;&lt;b&gt;ssl:&lt;/b&gt; SSL/TLS configuration and certificate analysis&lt;/li&gt;     &lt;li&gt;&lt;b&gt;dns:&lt;/b&gt; DNS configuration and zone transfer tests&lt;/li&gt;     &lt;li&gt;&lt;b&gt;whois:&lt;/b&gt; Registration and ownership information&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Quick scans:&lt;/b&gt; 30-60 seconds (subdomains, dns, whois)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Comprehensive scan:&lt;/b&gt; 5-15 minutes depending on infrastructure size&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Pre-engagement reconnaissance for penetration testing&lt;/li&gt;     &lt;li&gt;Attack surface assessment&lt;/li&gt;     &lt;li&gt;Infrastructure inventory and mapping&lt;/li&gt;     &lt;li&gt;Vulnerability management&lt;/li&gt; &lt;/ul&gt; 
     */
    @Test
    public void createInfrastructureScanTest()  {
        // uncomment below to test the function
        //ScanRequest scanRequest = null;
        //JobResponse response = api.createInfrastructureScan(scanRequest).block();

        // TODO: test validations
    }
    
    /**
     * Configure Monitoring Alerts (Asynchronous)
     *
     * &lt;p&gt;Create alert rules for a monitored asset. Get notified via webhook, email, or Slack when specific conditions are met.&lt;/p&gt; &lt;h4&gt;Alert Types:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;downtime:&lt;/b&gt; Site becomes unreachable&lt;/li&gt;     &lt;li&gt;&lt;b&gt;dns_change:&lt;/b&gt; DNS records modified&lt;/li&gt;     &lt;li&gt;&lt;b&gt;whois_change:&lt;/b&gt; Registration details updated&lt;/li&gt;     &lt;li&gt;&lt;b&gt;ssl_expiring:&lt;/b&gt; Certificate expires soon (7, 14, 30 days)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;content_change:&lt;/b&gt; Page content modified&lt;/li&gt;     &lt;li&gt;&lt;b&gt;technology_change:&lt;/b&gt; Tech stack changes detected&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Notification Channels:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Webhook (POST to your endpoint)&lt;/li&gt;     &lt;li&gt;Email&lt;/li&gt;     &lt;li&gt;Slack&lt;/li&gt;     &lt;li&gt;PagerDuty&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Example Configuration:&lt;/h4&gt; &lt;pre&gt;&lt;code&gt;{   \&quot;type\&quot;: \&quot;ssl_expiring\&quot;,   \&quot;threshold_days\&quot;: 14,   \&quot;channels\&quot;: [\&quot;email\&quot;, \&quot;slack\&quot;],   \&quot;email\&quot;: \&quot;alerts@example.com\&quot;,   \&quot;slack_webhook\&quot;: \&quot;https://hooks.slack.com/...\&quot; }&lt;/code&gt;&lt;/pre&gt; 
     */
    @Test
    public void createMonitoringAlertTest()  {
        // uncomment below to test the function
        //String target = null;
        //MonitoringAlertRequest monitoringAlertRequest = null;
        //JobResponse response = api.createMonitoringAlert(target, monitoringAlertRequest).block();

        // TODO: test validations
    }
    
    /**
     * Capture a Website Screenshot (Asynchronous)
     *
     * &lt;p&gt;Initiates an asynchronous job to capture a screenshot of a website. Supports various viewport sizes, full-page captures, and JavaScript rendering.&lt;/p&gt; &lt;p&gt;&lt;b&gt;Performance Note:&lt;/b&gt; A typical screenshot capture takes 10-30 seconds. Poll the &#x60;/v1/ops/jobs/{jobId}&#x60; endpoint to retrieve the URL of the final image.&lt;/p&gt; &lt;p&gt;&lt;b&gt;Output:&lt;/b&gt; The job result will contain a URL to download the screenshot image in the specified format (PNG, JPEG, or WebP).&lt;/p&gt; 
     */
    @Test
    public void createScreenshotTest()  {
        // uncomment below to test the function
        //ScreenshotRequest screenshotRequest = null;
        //JobResponse response = api.createScreenshot(screenshotRequest).block();

        // TODO: test validations
    }
    
    /**
     * Get Infrastructure Change History
     *
     * &lt;p&gt;Retrieves detected changes in infrastructure configuration for a domain or IP over time. Essential for security monitoring and compliance auditing.&lt;/p&gt; &lt;h4&gt;Change Types Tracked:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;dns:&lt;/b&gt; A, AAAA, MX, NS, TXT record changes&lt;/li&gt;     &lt;li&gt;&lt;b&gt;whois:&lt;/b&gt; Registrant, registrar, nameserver changes&lt;/li&gt;     &lt;li&gt;&lt;b&gt;ssl:&lt;/b&gt; Certificate replacements and expirations&lt;/li&gt;     &lt;li&gt;&lt;b&gt;ip:&lt;/b&gt; IP address changes for domains&lt;/li&gt;     &lt;li&gt;&lt;b&gt;content:&lt;/b&gt; Homepage content modifications&lt;/li&gt;     &lt;li&gt;&lt;b&gt;technology:&lt;/b&gt; Tech stack changes&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Response Format:&lt;/h4&gt; &lt;p&gt;Timeline of changes with before/after values:&lt;/p&gt; &lt;pre&gt;&lt;code&gt;{   \&quot;changes\&quot;: [     {       \&quot;timestamp\&quot;: \&quot;2025-01-15T10:30:00Z\&quot;,       \&quot;type\&quot;: \&quot;dns\&quot;,       \&quot;field\&quot;: \&quot;A_RECORD\&quot;,       \&quot;old_value\&quot;: \&quot;8.8.8.8\&quot;,       \&quot;new_value\&quot;: \&quot;1.1.1.1\&quot;     }   ] }&lt;/code&gt;&lt;/pre&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Security incident investigation&lt;/li&gt;     &lt;li&gt;Compliance and audit trails&lt;/li&gt;     &lt;li&gt;Detecting unauthorized changes&lt;/li&gt;     &lt;li&gt;Infrastructure change management&lt;/li&gt; &lt;/ul&gt; 
     */
    @Test
    public void getChangeDetectionTest()  {
        // uncomment below to test the function
        //String target = null;
        //String type = null;
        //String since = null;
        //api.getChangeDetection(target, type, since).block();

        // TODO: test validations
    }
    
    /**
     * Get Asynchronous Job Status and Results
     *
     * &lt;p&gt;Retrieves the current status and results of an asynchronous job. Poll this endpoint to check job progress.&lt;/p&gt; &lt;h4&gt;Polling Recommendations:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;For fast jobs (e.g., similar domains), poll every 1-2 seconds.&lt;/li&gt;     &lt;li&gt;For slow jobs (e.g., WHOIS search, screenshots), poll every 5-10 seconds.&lt;/li&gt;     &lt;li&gt;Implement an exponential backoff strategy for very long-running jobs.&lt;/li&gt;     &lt;li&gt;Stop polling when the status is &#x60;COMPLETED&#x60;, &#x60;FAILED&#x60;, or &#x60;CANCELLED&#x60;.&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Job Statuses:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;PENDING:&lt;/b&gt; Job is queued and waiting to start.&lt;/li&gt;     &lt;li&gt;&lt;b&gt;PROCESSING:&lt;/b&gt; Job is actively being processed.&lt;/li&gt;     &lt;li&gt;&lt;b&gt;COMPLETED:&lt;/b&gt; Job finished successfully, results are available.&lt;/li&gt;     &lt;li&gt;&lt;b&gt;FAILED:&lt;/b&gt; Job failed with an error.&lt;/li&gt;     &lt;li&gt;&lt;b&gt;CANCELLED:&lt;/b&gt; Job was cancelled by user or system.&lt;/li&gt; &lt;/ul&gt; 
     */
    @Test
    public void getJobTest()  {
        // uncomment below to test the function
        //String jobId = null;
        //Job response = api.getJob(jobId).block();

        // TODO: test validations
    }
    
    /**
     * Get Monitoring Status and Metrics
     *
     * &lt;p&gt;Retrieves current monitoring configuration and historical metrics for a domain or IP address.&lt;/p&gt; &lt;h4&gt;Status Information:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Monitoring State:&lt;/b&gt; Active, paused, or not monitored&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Check Frequency:&lt;/b&gt; How often checks are performed&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Active Alerts:&lt;/b&gt; Currently triggered alert conditions&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Last Check:&lt;/b&gt; Timestamp of most recent check&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Metrics Included:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Uptime percentage (last 30 days)&lt;/li&gt;     &lt;li&gt;Average response time&lt;/li&gt;     &lt;li&gt;SSL certificate expiration countdown&lt;/li&gt;     &lt;li&gt;DNS change events&lt;/li&gt;     &lt;li&gt;WHOIS change events&lt;/li&gt; &lt;/ul&gt; 
     */
    @Test
    public void getMonitoringStatusTest()  {
        // uncomment below to test the function
        //String target = null;
        //api.getMonitoringStatus(target).block();

        // TODO: test validations
    }
    
    /**
     * Get Screenshot History
     *
     * &lt;p&gt;Retrieve all previously captured screenshots for a specific URL, ordered by capture time (newest first). Includes download URLs and metadata for each capture.&lt;/p&gt; &lt;h4&gt;Response Includes:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Download URL:&lt;/b&gt; Direct link to screenshot image&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Capture Time:&lt;/b&gt; Timestamp when screenshot was taken&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Dimensions:&lt;/b&gt; Image width and height&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Format:&lt;/b&gt; Image format (PNG, JPEG, WebP)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;File Size:&lt;/b&gt; Size in bytes&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Review website evolution over time&lt;/li&gt;     &lt;li&gt;Compare screenshots for change detection&lt;/li&gt;     &lt;li&gt;Download historical screenshots for reporting&lt;/li&gt; &lt;/ul&gt; 
     */
    @Test
    public void getScreenshotHistoryTest()  {
        // uncomment below to test the function
        //String url = null;
        //Integer limit = null;
        //api.getScreenshotHistory(url, limit).block();

        // TODO: test validations
    }
    
    /**
     * List Recent Jobs
     *
     * &lt;p&gt;Retrieves a list of recent jobs for the authenticated user, optionally filtered by status.&lt;/p&gt; &lt;h4&gt;Query Parameters:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;status:&lt;/b&gt; Filter by job status (PENDING, PROCESSING, COMPLETED, FAILED, CANCELLED)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;limit:&lt;/b&gt; Maximum number of jobs to return (default: 50, max: 100)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;offset:&lt;/b&gt; Number of jobs to skip for pagination (default: 0)&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Response Format:&lt;/h4&gt; &lt;p&gt;Returns a JSON object with a \&quot;jobs\&quot; array containing job summaries.&lt;/p&gt; 
     */
    @Test
    public void listJobsTest()  {
        // uncomment below to test the function
        //String status = null;
        //Integer limit = null;
        //Integer offset = null;
        //api.listJobs(status, limit, offset).block();

        // TODO: test validations
    }
    
    /**
     * Schedule Recurring Screenshots (Asynchronous)
     *
     * &lt;p&gt;Create a recurring job to capture website screenshots at regular intervals. Essential for monitoring website changes, detecting defacements, and tracking competitor updates.&lt;/p&gt; &lt;h4&gt;Schedule Options:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Cron Expression:&lt;/b&gt; Full cron syntax support (e.g., &#x60;0 0 * * * *&#x60; &#x3D; hourly)&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Frequency Presets:&lt;/b&gt; hourly, daily, weekly, monthly&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Timezone:&lt;/b&gt; Specify timezone for accurate scheduling&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Retention:&lt;/b&gt; Auto-cleanup old screenshots (default: keep last 30)&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;&lt;b&gt;Setup Time:&lt;/b&gt; ~2 seconds to create schedule&lt;/li&gt;     &lt;li&gt;&lt;b&gt;Screenshot Time:&lt;/b&gt; 10-30 seconds per capture&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Use Cases:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Automated defacement detection&lt;/li&gt;     &lt;li&gt;Compliance monitoring and archival&lt;/li&gt;     &lt;li&gt;Competitor website tracking&lt;/li&gt;     &lt;li&gt;Visual regression testing&lt;/li&gt; &lt;/ul&gt; 
     */
    @Test
    public void scheduleScreenshotTest()  {
        // uncomment below to test the function
        //ScreenshotRequest screenshotRequest = null;
        //JobResponse response = api.scheduleScreenshot(screenshotRequest).block();

        // TODO: test validations
    }
    
    /**
     * Find Similar Domains (Asynchronous)
     *
     * &lt;p&gt;Generates potential lookalike, typosquatting, and homoglyph domains for brand protection and threat hunting.&lt;/p&gt; &lt;h4&gt;Detection Methods:&lt;/h4&gt; &lt;ul&gt;     &lt;li&gt;Typosquatting (keyboard proximity)&lt;/li&gt;     &lt;li&gt;Homoglyph attacks (visually similar characters)&lt;/li&gt;     &lt;li&gt;Combosquatting (brand + keyword)&lt;/li&gt;     &lt;li&gt;TLD variations&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;Performance:&lt;/h4&gt; &lt;p&gt;Typically completes in 5-15 seconds depending on options.&lt;/p&gt; 
     */
    @Test
    public void similarDomainsTest()  {
        // uncomment below to test the function
        //SimilarDomainsOpsRequest similarDomainsOpsRequest = null;
        //JobResponse response = api.similarDomains(similarDomainsOpsRequest).block();

        // TODO: test validations
    }
    
}
